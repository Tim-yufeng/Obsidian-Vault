# 1. Introduction to Digital Design
## Digital和Analog简介

Digital signal: 数字信号，离散的、有限的可能
Analog signal：模拟信号，连续的、无限的可能
模拟信号到数字信号的转换：From analog to digital, 被称为 A2D/Digitization
意义：模拟信号容易在传播途中失真（因外界干扰因素），而数字信号因为简单，即使失真也容易恢复，因此适合用于传输
显然模拟信号包含的信息更多，因此A2D其实可以类比186中对积分的定义，用小矩阵去拟合逼近曲线，但是需要更多的 bits
![[Pasted image 20250915193049.png]]
既然数字信号更适合远程传输，那么一个我们要做的就是在传输前将模拟信号变成数字信号，传输过去后再变回来
![[Pasted image 20250915193352.png]]  
## 二进制、十六进制和八进制
二进制变成十进制很简单，只要明确每个位置的权重，再一起加起来就可以了，下图展示了考虑小数的情形：
![[Pasted image 20250915193711.png]]  
由此我们得到，$10011.01_2 = 16+2+1+0.25 = 19.25_{10}$ 

而十进制变成二进制则稍麻烦，一种方法就是直接拆解成2的次方的组合，比较适合人类。

另一种方法是：对于整数部分，不断整除2取余，将余数按照从右往左 ($\longleftarrow$) 的方向，也就是从小到大，排开就组成了二进制数的整数部分。
小数部分则不断乘以2，每次乘以2，如果大于1，则记1然后减去1，否则直接记0。将每次记录的数从左往右（$\longrightarrow$）排，就得到了小数部分。
要注意的是，不是所有十进制小数转化到二进制都是有限的（上述过程无限重复下去，永远不能被减到0的情况），比如 $0.1_{10}$ 在二进制中是无限循环小数。
By the way，许多十进制简单的小数到了二进制却变成了无限循环小数，这也正是计算机浮点数精度误差的来源。

这里仅展示小数部分的获得方式：
![[Pasted image 20250915215220.png]]  


十六进制原理上和二进制差不多，和十进制的转化的方法也大同小异。
之所以十六进制重要，是因为二进制在计算机内的储存方式是四个bit一组，也就是四位二进制数一组，而这一组bits所能表示的数刚好是16个，也就是十六进制的一个数，因此我们可以将一个巨大的二进制数分成四个一组，然后每一组直接转换成十六进制的一个数，看着就清爽多了，如下图所示：
![[Pasted image 20250915215756.png]]  
八进制的用武之地和十六进制差不多，不过现在已经被逐渐淘汰了，我们了解即可。

二进制比特表示文字：ASCII or Unicode (See slides for details)

## 负数的二进制表示

用二进制表示负数时，一种方法是，由最左边的bit代表符号，其中0为正，1为负，其余部分表示绝对值，比如 $1100_2$=$-4_{10}$ *(sign and magnitude)*

另一种方法是，将四个bits的每一个bit都flip一下，1变成0，0变成1，比如$0011_2=3_{10}$, $1100=-3_{10}$ *(1’s complement representation)*

第三种方法是，像第二种一样取反每一个bit，然后加上1，此时 $-3_{10}=1100+1=1101$ *(2’s complement representation)*

<span class="red">现代计算机采用的是第三种方法。</span>
在第三张方法下，对于正数，在最左边添加0不会改变这个数的值，对于负数，增加1不会改变值。这些增加的0或1被称为 sign extension
(<span class="green">第三种方法的优越性在于，它能够最大化利用所有bit，将 $2^n$ 种组合方式完全用于 $-2^{n-1}$ 到 $2^{n-1}-1$ 的表示，每个数唯一对应，没有“正零”和“负零”的冗余（原码和反码都有这个问题）。</span>)

在考虑了正负号后的二进制加减运算，一种方法是先遵循2's complement 将每个参与运算的数转换成符号+大小的形式，然后直接进行十进制计算；另一种就是直接进行竖式计算，只在最左边一位考虑是否舍弃最末的carry。

对于n个比特，2’s complement representation表示的范围是 $-2^{n-1}$ 到 $2^{n-1}-1$, 而如果一个n 比特的2’s complement number超过了这个范围，就称之为Overflow（溢出）。
发生溢出时，也就是**运算结果超出了当前位数2’s complement representation所能表示的范围**，最前面的carry需要保留，否则舍去。

判断是否Overflow最简单的方法是，<span class="red">次高位给最高位（or符号位）带来的进位若不等于最高位自己产生的进位，则代表Overflow。</span>
![[Pasted image 20250917201609.png]]

- [x] 270 HW 1 🛫 2025-09-17 📅 2025-09-23 ✅ 2025-09-23
作业收获：
 - 正数的二进制不用担心“最高位是 1 就是负数”，那只有在固定位宽二补数下才成立。
    
- 做运算时，先统一位宽：正数前面补 0，负数前面补 1。
    
- 转换时保持 3 位（八进制）或 4 位（十六进制）的分组，只是为了方便阅读，并不是强制要求。
一个有趣的问题是，$1000_2$ 代表负多少，因为按照 “Flip 后加1” 的操作，$1000_2-1=0111_2 \rightarrow(flip) 1000$, 回到了他自己，这是为什么？
其实是因为，n位二进制数在2’s complement representation 规则下只能表示 $-2^{n-1}$ 到 $2^{n-1}-1$ 这个范围，注意到负数的范围比正数多一个整数，所以其实是 $1000_2=-8$, 但是相应的正数8不在4位表示范围内，4位最多表示到7. 
如何知道$1000_2=-8$ ？这就需要另一个公式,对于开头是1的二进制数，也就是负数，满足：
$$值=−2^{n−1}+其余位的值$$ 其余位的值 就是除了最高位以外的部分视为一个二进制正数，它代表的值
对于$1000_2$，我们有$-2^3 +000_2=-8+0=-8$ 
# 2. Basic Logic Gates
## Transistor（晶体管）
本质是 electronic switch，是二进制数字电路的根基
特征：
- 是一个开关器件，是开是关由输入端电压决定
- 开：允许电流通过，关：阻断电流
- 其开关状态可以表示二进制逻辑：1/0
transistor分为两种：positive MOS 和 negative MOS， 如下图所示：
![[Pasted image 20250917211314.png]]  
其中1代表高电压，0代表低电压或无电压（低于阈值的电压）
nMOS在高低压导通，低电压阻断；pMOS则相反

通过这两种晶体管的组合，可以形成以下三种逻辑门：

<p align="center">
  <img src="Pasted image 20250917212014.png" width="200"/>
  <img src="Pasted image 20250917212058.png" width="200"/>
  <img src="Pasted image 20250917212107.png" width="200"/>
</p>
这三种逻辑门的运算顺序是：**NOT>AND>OR**

另一种表示逻辑输入输出的方式是Timing Diagram, 也叫 wave form, 可以描述电压信号随时间的变化特征；（其实就是不连续变化的波形图，振幅-时间的那种）
![[Pasted image 20250922163223.png]]  

更多的逻辑门包括 NAND, NOR, XOR, XNOR, 其中加上N代表……的否定，如下图所示，通过一个圈代表NOT, 而XOR表示输入的“1”个数为奇数时输出1， 否则输出0（毕竟某种意义上，二进制中1+1=0）
![[Pasted image 20250922165354.png]]
（现实中NAND和NOR比AND和OR更常用。）

逻辑电路的绘制有一些约定俗成的规则，如下图所示，有些画法是不被允许的：
![[Pasted image 20250922185356.png]]  
# 3. Boolean Algebra & Optimization
## 一些专业术语
- variable: 就是逻辑表达式中的变量，和函数变量一样
- Literal: 一个变量，以自己或者取反的形式，出现一次，就是一个literal
- Product term： AND of literals
- Sum: OR of literals
- Sum-of-products: 完全写成多项相加的式子
这是一个例子：
![[Pasted image 20250922190502.png]]  

## Boolean Algebra的基本定理
下面这些是最基本的，记住的诀窍是不要从数学的角度，从逻辑的角度（不要把 $\cdot$ 和 + 当成乘号和加号，要当成 and 和 or
![[Pasted image 20250922190554.png]]
下面这些就相对复杂了，它们由上面的基本定理推导而来，目的是化简逻辑表达式
![[Pasted image 20250922190606.png]]
<span class="green"> 由absorption 等式的思考，形如 $F=x(x+y_1)(x+y_2)……(x+y_n)$, 结果都是 $x$，这是因为，$x$ 单独作为一项product，使得 $x$ 具有“一票否决权”，而每一项 product 使得 $x=1$ 是整个式子等于1的充分条件，如此一来，$x=1$ 是$F=1$的充分必要条件。</span>

**DeMorgan’s Law**
$$(x+y)'=x'y'$$
$$x'+y'=(xy)'$$

运算顺序之前提过，这里再说一次：  
==括号>NOT>AND>OR==
(你会发现和它们相应的数学符号的运算顺序是一样的)

XOR 运算因为很常用，这里也介绍一下它的运算法则：
![[Pasted image 20250922191842.png]]
一个将XOR换算成前面的基本逻辑运算的公式：
$$ A \oplus B = AB'+A'B$$ 
## Minterm and Maxterm

Minterm: n 个变量的积项（AND），并且每个变量必须出现一次（要么取正，要么取反）
比如变量是 $a, b, c$，一个可能的 minterm 是 $a b' c$。
用 $m_i$ 表示，第 $i$ 个 minterm

Maxterm: n 个变量的和项（OR），并且每个变量必须出现一次（要么取正，要么取反
比如变量是 $a, b, c$，一个可能的 maxterm 是 $(a + b' + c)$
用 $M_i$ 表示，第 $i$ 个 maxterm 

下图展示了排序的依据：
![[Pasted image 20250922193712.png]]  
实际就是上将literals们的组合方式对应到二进制，将相应的值作为$i$值了。
之所以叫 Minterm，是因为三个字母都仅出现一次，是满足“仅使得某种组合输出结果为1”的最短组合。
这种组合也是最基本的组合，被用于组合更复杂的逻辑表达式，也就是 sum-of-minterms (**standard-sum-of-products**)
举个例子：
![[Pasted image 20250924192733.png]]  
如图所示，我们可以把这种组合简写作$m_i$相加的形式，或者写成对应的脚标的求和的形式。

关于Maxterm就不多说了，因为Minterm和Maxterm可以依据 DeMorgan’s Law 相互转化，有：
$$m_i'=M_i$$ 比如，$m_0=x'y'z'$，$m_0'=(x'y'z')'=x+y+z=M_0$，
然后他们用于组合表示逻辑表达式时，index是相反/互补的：
比如：如果总共有7项，那么$\sum{m(1, 2, 4, 7)}=\prod{M(0, 3, 5, 6)}$
## Incompletely Specified Functions
还有一类逻辑表达式比较特殊，它们的某些输出我们并不care，可以是0可以是1，也就是不完全定义 (**Incompletely Specified Functions**) 
![[Pasted image 20250924194132.png]]  
我们在 truth table 的相应位置标识 "x", 代表未定义，同时在表达式里写作 $d(\cdots)$ 

# 4. Logic Optimization
## 优化简述
Optimization有两个基本指标，一是延迟减少，二是尺寸减小，其中这两个指标分别对应：
- Delay: 从输入到输出的最多层数
- Size: transistor的数量
我们可以简单的假设：
1. 每个逻辑门都产生 "1 gate delay"
2. 每个逻辑门的输入需要2个transistor
3. 不考虑NOT逻辑门，也就是 inverter
一个简单的例子：![[Pasted image 20250924202614.png]] 右边的逻辑电路和左边等价，但是transistor数量和逻辑门层数都更少，意味着它的滞后时间和尺寸都更小，因此是更优设计

要注意的是，这两个优化指标并不总是能像这样同时取得的，很多时候会面临选择低延迟，但是增大尺寸，或者反过来的局面，这个时候的设计要考虑具体需求。

从输入到输出的最长延迟路径被称作 **Critical path** 

那么，如何Optimize呢？

## Karnaugh Map (K-map) Technique

优化的方法除了 Boolean Algebra，还有Karnaugh-map
如何理解这个方法？
### 1. 从“每个格子 = 一个最小项”开始

- K 图上的每个格子，代表一个 **minterm（最小项）**。
    
- 如果不化简，函数就得写成所有“格子对应的最小项之和”。
    
### 2. 为什么可以“画圈合并”？

- 在 K 图的布局下，**相邻格子之间只差一个变量取值**。
    
- 例如：
    
    - 格子1 = $A B' C D$
        
    - 格子2 = $A B C D$
        
    - 它们相邻，只差 $B$，所以
        
        AB′CD+ABCD=ACD(B′+B)=ACDA B' C D + A B C D = A C D (B'+B) = A C DAB′CD+ABCD=ACD(B′+B)=ACD
    - 这样就**消去了一个变量**。
        

所以，“画圈”的本质 = 通过邻接性，把一组最小项合并成一个更简的项。

---

### 3. 为什么圈的大小必须是 2 的次方？

- 如果一个圈包含 **2 个格子**，说明消去 1 个变量；
    
- 如果一个圈包含 **4 个格子**，说明消去 2 个变量；
    
- 如果一个圈包含 **8 个格子**，说明消去 3 个变量；
    
- …依此类推。
    

这是因为：

- 每消去一个变量，对应情况数翻倍（2 个格子）；
    
- 所以圈内格子数 = $2^k$，其中 $k$ = 被消去的变量数。
    

---

### 4. 化简的目标

- 起点：每个“1”格子单独表示 → 全部变量都在。
    
- 过程：通过圈合并，**去掉不必要的变量**。
    
- 终点：找到覆盖所有“1”的最简表达式。

- [x] HW 2 ⏫ 📅 2025-10-13 ✅ 2025-10-06

在 Karnaugh-map 方法中，如果碰到某些格子是 "Don't care", 我们在相应的格子标 "X", 在画圈时，它们可以扮演1也可以扮演0. 

在 Karnaugh-map 中无法被一个更大的圈完全覆盖的区域，称为 prime implicant (PI). 
![[Pasted image 20250929162333.png]] 
如果**存在一个格子，有且仅有该 PI 覆盖到它**，那么这个PI就是一个 **essential PI**.

如果一个 PI 中所有最小项都能被其它 PI 覆盖，那么这个 PI 就是不必要的，反之，如果存在一个只能被该 PI 覆盖的最小项，那么这个 PI 就是必要的，在最终表达式中无法被其它 PI 替代

==还有一种优化思路==，就是将 K-map 上所有数字反转，这样就是输出结果取逆的 K-map. 写出它的化简后的逻辑表达式，然后再逆回去，可能会起到意想不到的效果

因为 K-map 法化简结果是 sum-of-product，如果先取逆后在外层逆回去，那么运用 DeMorgan's Law, 我们就可以把 sum-of-product 形式变成 product-of-sum 形式 {.green}

## 能量的优化

还有一种优化方向，就是让芯片的能量消耗最低：
芯片的能量消耗主要来自0到1的切换
![[Pasted image 20250929170817.png]] 

# 5. Combination Circuit
数字电路可以分为基础的两类，combination circuit（组合逻辑电路） 和 sequential circuit（时序逻辑电路）

Combination circuit：输出只依赖于当前输入，和历史输入无关

Sequential circuit：输出不仅取决于当前输入，还取决于电路的历史状态（有记忆功能）

Combination Building Blocks：某些功能的电路非常常用和基础，比如：
![[Pasted image 20251011162936.png]] 
### Building Block 1——Mux
Mux 的本质是信号的选择器，通过 select input的输入值，决定另外的多个输入值哪个作为输出结果：
![[Pasted image 20251011163052.png]] 
一个Mux的设计过程，将 普通输入和选择输入都视为输入，输出结果就是选择的结果，然后得出 truth table:
![[Pasted image 20251011163226.png]] 
一个小概念，有种一下子输入多个 bits 的输入，称为 bus, 相当于将多根信号线打包成一匝。
### Building Block 2——Half Adder
将两个输入加起来，输出分别是结果值和carry。
![[Pasted image 20251011170150.png]] 
而这个电路图还可以进一步简化，因为 A'B+AB' 可以用 XOR 替代：
![[Pasted image 20251011170515.png]] 
### Building Block 3——Full Adder
Full adder 和 half adder 的唯一区别其实就是输入多了一个：
<p align="center">
  <img src="Pasted image 20251011184338.png" width="200"/>
  <img src="Pasted image 20251011184755.png" width="200"/>
</p>
可以运算三个数相加的结果，但是这个第三个输入时有讲究的，通常是接前一个 Full adder 的 carry，这样一个一个 Full adder 之间 carry 对输入3，就形成了一个可以计算多位二进制数的大 adder:
![[Pasted image 20251011185104.png]] 
如果要减法器 Substractor 呢？减法就是将减数取负的加法，运用 two's complement, 先全部反转，然后加1，可以设计出这样的电路：
![[Pasted image 20251011185338.png]]
不能忘了 最大一位的 Overflow 问题，回顾一下，如果次高位的 carry 和最高位的 carry 不一样，则要加上 Overflow，否则不用，于是我们可以通过在最高位和次高位各自的 Full adder 的 carry 输出用一个 XOR门连接，从而可以直接判断它俩是否相等，（但是如何根据是否相等在最高位补上相应的 carry 实现起来更复杂一些，没有课件图那么简单）
<p align="center">
  <img src="Pasted image 20251011185822.png" width="320"/>
  <img src="Pasted image 20251011185834.png" width="320"/>
</p>
如何设计一个能兼容加法器和减法器的电路？运用之前的选择器，我们可以拿 C0 作为选择输入，就是 C0 既是最右边的那个第三输入值，也是 B 系列输入的选择器，C0=0 时为加法，B系列直接输入，C0=1 时为减法，B系列所有输入都加上一个取反门。
### Arithmetic-Logic Unit: ALU
看似复杂，实际就是通过选择器将执行各种运算方式的电路合并起来了，嗯，确实有点复杂。但是原理很简单。
![[Pasted image 20251011190239.png]]

### Encoder and Decoder
这两个combination blocks 的作用可以用下面两幅图简单概括：
<p align="center">
  <img src="Pasted image 20251013225827.png" width="320"/>
  <img src="Pasted image 20251013225851.png" width="320"/>
</p>
Encoder: $2^N$ 个输入，$N$ 个输出，可以理解为十进制到二进制的转换？
Decoder: $N$ 个输入，$2^N$ 个输出，可以理解为是对二进制的解译，也可以视作一个 ==Minterm Generator==, 因为它的输出个数其实就是输入的二进制编码的所有组合形式，然后一个输出只可能有一个是1，这恰好就是 Minterm 的形式。

进一步理解 "Minterm Generator" 这件事，观察上面这张图，每一行的那个“1”对应的是一种组合，也就是一个Minterm，而8行就涵盖了3个Input的所有可能组合，也就是所有Minterm。

那么对于任意一个 $N$ 个输入的逻辑电路，我们可以从$N$ 个输入Decoder 的输出中选出需要的 Minterm 项，用它们组成我需要的输出。

### Buffer and Three State (Tri-state) Buffer
==Buffer== 的本质：一个**信号驱动增强器**，就像一个“中继器”，它不改变信息内容，只是让信号“更强”、“更稳”地传输；

Buffer 在实际应用中的作用有：增强驱动能力，隔离输入输出，引入延迟，确保单向传输（防止信号反向流动）等

==Three State (Tri-state) Buffer==（三态缓冲器）：相比普通 buffer 只有两种可能的输入输出：$1\to 1$, $0\to 0$, three state buffer 多了一个 “控制端” 输入，这个输入为 1 时，和普通 Buffer一样，如果为0，无论另一个输入是什么，输出都是 高阻态 Z

注意 Z 和输出为0 是不一样的，Z 表示 **High Impedance（高阻态）**，意思是：

- 输出端相当于“断开”，不输出任何电压；
    
- 这样多个设备可以共用同一条输出线，而不会互相冲突。
    

例如在总线结构中，不同模块可以通过 enable 控制哪一个设备当前“占线”。

结合 inverter, 我们有三种 Tri-state Buffers, 它们的结构及 truth table如下图所示：
![[Pasted image 20251014144125.png]]
注意到，Tri-state buffer 可以起到==选择是否导通信号==的作用，而之前介绍的 Deconder可以起到选择各种 Minterm 的作用，那么其实一个 Tri-state buffer 加上一个 Decoder 就可以起到 ==通过 $N$ 个输入决定 $2^N$ 个值哪个作为输出== 的作用，如下![[Pasted image 20251014144714.png]]图所展示的。诶？这其实就是一个 $8\times1$ Mux. 
![[Pasted image 20251014144714.png]]

- [x] 270 HW3 ⏫ 📅 2025-10-20 ✅ 2025-10-17

# 6. Latches and Flip Flops
我们现在要实现一个电路，有两个输入（或者说 按钮）和一个输出（一个灯），按钮按下信号为1，松开为0，然后我们希望的效果是：这两个按钮一个是 call， 一个是 cancel，当 call 键按下后，灯亮，并且在松开后依然保持亮；当cancel 按下，无论灯之前状态如何，都保持熄灭。

Combinational circuits 已经无法解决这个问题，因此我们需要 sequential circuit， 也就是输出结果取决于：
- 当前输入
- 之前输入
- 之前输出
这个电路的实现叫 SR Latch:
## SR Latch
SR  Latch 电路如下，由一个 set input， 一个 reset input, 和一个 Q 输出构成，上面 NOR gate 的输出我们通常叫 t: 
![[Pasted image 20251014154455.png]]
其中 S input 就是上面例子中的 Call 按钮，reset则是 Cancel 按钮，然后 Q 就是直接控制灯的输出信号。

整个电路的工作原理可以用下面的各口信号值变化图，和 timing diagram 展示：
![[Pasted image 20251014154844.png]]
简单解读一下：一开始两个按钮都是松开状态，但是灯已经被点亮了，此时可以推断出 t 值是0，这时按下 reset 按钮，引起的连锁反应是：首先 Q变0，灯熄灭，然后导致t 变1，t 的值又回到下面的门的另一个输入，因为这个1的存在，即使 reset 按钮随后松开，R 回到0，t 依然维持着 Q 为 0，而在 S 被按下前，Q=0 反过来维持着 t=1, 如此 t 和 Q形成了一个相互制约，相互维持，电路达到稳态。

这时如果 S 按下，S=1 直接导致 t=0, 而由于 R 未按下，t=0 导致 Q=1, 灯亮，Q=1 反过来维持了 t=0，即使 S 随后松开，Q=1 和 t=0 也能相互维持，于是电路再次达到稳态，灯保持亮。

SR Latch有个缺陷，注意到，在上述的分析中，电路的每次达到稳态都有个前提，就是一个按钮按下时，另一个按钮必须保持松开。
事实上，一旦两个按钮同时按下，**输出灯可能闪烁、抖动，甚至短暂地不确定**。
当按钮松开（S=R=0）后，锁存器可能“随机”进入 Set 或 Reset 状态，取决于哪个信号路径恢复得更快（微秒级差异）

### Representation of SR Latch 
研究 SR latch， 时，我们需要区分输出 Q 在不同时间的输出，一个是当前状态 present state，是进行一步操作之前的初始条件；另一个是未来状态 next state, 是这一步操作导致的结果。
![[Pasted image 20251014160859.png]]

### SR Latch 的一个等价
有意思的是，存在一个几乎和 SR Latch 等价的电路，由 NAND 实现，如下图所示：
![[Pasted image 20251014161116.png]]
注意到，这个电路的 characteristic table 和之前 SR Latch是”相反的“，换句话说，如果将S，R输入全部取反，两个电路将完全等价。
### Gated SR Latch
gated SR latch 就是在 SR latch 前面再套了一层 AND 门，并且增加了一个控制输入 G
![[Pasted image 20251014163834.png]]
如图所示，当 G=1 时，一切正常进行，这个电路就是一个普通是 SR Latch；如果 G=0，整个电路锁死。（套上两个 AND 门的意义就是，S 和 R 信号必须在 G=1 的时候才能传过去，否则，S1 和 R1 都只能是0）

### Gated D Latch
前面提到，SR latch 的一个问题是，如果 S 和 R 同时为 1，整个电路会陷入失控状态，这个问题的解决方法就是 Gated D latch.

Gated D latch 和 Gated latch很像区别就是将 S 和 R 从相互独立，改为强制相反：
![[Pasted image 20251014164759.png]] 

Gated D latch 的性质是，当 G=1 时，相当于一个强制使得 S, R 保持相反的 SR latch，这时 D=1 时 Q=1，D=0 时 Q=0

当 G=0 时，整个电路进入一个”锁定“ 状态，此时无论 D 怎么变化都影响不到 Q 的值，Q 保持不变，直到 G 再次开启。因此通过控制 G 的开关，我们可以用这个电路实现 bit 的储存，==即实现输入信号改变之后，之前输入的哪个信号依然被保存下来==。

![[Pasted image 20251014170410.png]]

## D Flip Flop
介绍 flip flop 之前，先要介绍 Clock Signal 的概念，简单来说，就是一串周期性的脉冲信号，类似正弦函数，不过只能取到0和1：

![[Pasted image 20251015185522.png]]

Rising-edge triggered D flip flop, 其实现电路图和 characteristic table 如下图所示，简单来说，==就是输出值 Q 在每次 Clock Signal 出现 rising edge 的时候，和 D 值对齐一次==。
在其他时候，Q 的值保持不变。因此说 Rising-edge triggered D flip flop 是 **Edge Sensitive** 的
Timing Diagram 可以看这张图：
![[Pasted image 20251015190234.png]]

其实存在两种 D Flip-Flop，一种是左图那样，是 rising edge triggered, 按 Clock Signal 出现升高行事，另一种是右图那样，在 input 处加上了一个inverter，是 falling edge triggered，按 Clock Signal 出现降低行事。

![[Pasted image 20251015190738.png]]

还有就是注意，图中那个三角形是 flip flop 的标志，如果元件中出现那个，代表这是某种 flip flop

下面是 D Flip Flop 的一个应用，这四个 FF 共用一个 Clock Signal，当出现升高信号时，每一个 Q 都会接收到前一个 FF 返回过来的信号，从而实现信号的一次向右传递（即每个信号向右移动一个 FF）

这是 FF 和 Latch，两种基本的，可以储存信号的时序电路，的一个对比：

![[Pasted image 20251015191737.png]]

FF 因为其变化只能发生在 Clock Signal 的变化边缘，其行为严格依赖于时钟信号的边沿，因此其动作是 **同步的**（Synchronous）。这意味着触发器的输出变化总是与时钟信号的边沿对齐。

Latch 的动作取决于输入控制信号，只要控制信号处于有效电平（高电平或低电平），锁存器就会根据输入信号的变化立即更新输出。其行为不受时钟信号边沿的限制，而是直接响应输入信号的变化，因此其动作是 **异步的** (Asynchronous)

<span class="green"> 由于触发器 FF 的动作仅在时钟边沿发生，它可以有效地滤除输入信号中的毛刺（Glitch）或其他短暂的干扰。
而锁存器 Latch 对输入信号的变化非常敏感，它容易受到毛刺或其他噪声的影响，导致输出不稳定。</span>

### Other Flip-Flop——J-K Flip Flop
![[Pasted image 20251015192953.png]]

这里的 characteristic table 没有明确表示时钟信号的存在，但是这个电路毕竟还是一个 FF，J 和 K 输入的结果只有在有 rising signal 的时候才见效。
### Other Flip-Flop——T Flip Flop

![[Pasted image 20251015193049.png]]

注意到，同是 FF，D Flip-Flop 的一个输入实现的是输出 Q 的变1或变0，相当于 set 和 clear 的功能，而 T Flip-Flop 同样是一个输入，实现的是输出 Q 的保持和反转 (hold or toggle)；
J-K Flip-Flop 有两个输入，实现的效果其实是 D FF 和 T FF 功能的整合。

<span class="red"> **Still, D latch and D flip flop: most popular** </span>
## Basic Register
本质就是，将多个 D flip flop 公用一个 clock, 除此之外没有联系，各自存储各自的输入信号。
每次输入信号更新并且出现一次 signal rising, 就进行一轮新的存储
![[Pasted image 20251015170635.png]]
如果要记录下过去各个时间点的数据（比如温度），可以将多个 Register 共用 clock signal 串联起来：
![[Pasted image 20251015170956.png]]
如此一来，信号不断向右转移，相邻 Register 记录的信号相差两个 clock rising signal 间的时间间隔。
最左边的 Register，$R_{a}$ 存储的是最新的信号，越往右信号越早。

一个 FF，加上了两个控制输入：set, clear 后，整个电路可以脱离 clock signal 的控制，变成异步控制：

![[Pasted image 20251015212712.png]]
注意看，Set 和 clear 上方有个 $\bar{}$ , 这代表取反，就是说，当 Set 输入 0，为有效电平，此时 Clock 对电路的控制被无视，输出 Q 被 Set 直接控制，变成 1，当 Clear 输入 0，为有效电平，此时 Clock 也会被无视，输出 Q 被 Clear 直接控制，变成 0.
下图展示了这种电路的变化：
![[Pasted image 20251015213111.png]]

### Register with Synchronous Parallel Load
这是一种特殊的 Register（寄存器），在 D 口前面加上了一个 $2\times 1$ 的 Mux，一个输入是正常的输入 $I_{0}$, 另一个是输出 Q。

这么做的效果是，如果 load（就是选择输入）是 0，也就是选择了 Q 作为输入，那么输出将会保持为现有的触发器值 Q 不变，当 load=1 时，MUX 选择新的加载值（I0）作为输入，触发器在时钟信号的上升沿将 I0 加载到输出 Q。

![[Pasted image 20251015232050.png]]

- [x] 270 HW 4 ⏫ 📅 2025-10-27 ✅ 2025-10-26

# 7. Verilog HDL
下图展示了一个最基本的逻辑电路的 HDL 描述：
![[Pasted image 20251020232324.png]]

1. 我们将对一个模块的定义包括在 module --- endmodule，就像 Latex 的 begin --- end 一样
2. module name 后面的括号中是模块的输入和输出端口，这里要注意，习惯的写法是输出口在前，输出口在后，这个顺序必须记住，因为后面如果要使用该模块，必须遵循这里定义的顺序
3. wire 可以理解为就是一种 Verilog 中的数据类型，代表模块中的“中途信号”，区别于输入信号和输出信号
4. 下面三行就是基本逻辑门的初始化，基本逻辑门是可以直接使用的模块，需要在括号内写明该逻辑门的输入输出口，==注意！必须遵循输出口在前，输入口在后==

一般实例化已定义的模块时，必须遵循定义时的端口顺序。一种情况例外，就是如下图红字，用 ==定义端口名.(实例化端口名)== 的方法，相当于手动指定，这样顺序可以随意。

以下展示了存在 bus 时的写法：
<p align="center">
  <img src="Pasted image 20251020234227.png" width="320"/>
  <img src="Pasted image 20251020234240.png" width="320"/>
</p>
回到 wire 变量，这个变量的定义其实是可有可无的，就是说，wire定义这一行可以直接略去，这样当下面实例化逻辑门用到 w1, w2 ... 的时候，编译器会自动将这些既不是输入也不是输出的家伙们视为 wire 

![[Pasted image 20251020234537.png]]

逻辑门定义的顺序完全不重要，全部列出来即可，是不是有点 C++ 面向对象编程的感觉？

以上我们讨论的都是 Structural Model 方法描述电路，还有一种方法，叫 RTL Model

简单来说，Structural Model 试图描述的是逻辑电路的结构，而 RTL Model 试图描述的是电路的 function

如下图所示，我们可以直接用 assign 方法，写出每个输出口的逻辑表达式，然后就结束了：

![[Pasted image 20251020234931.png]]
（是不是简单多了）

这一页要注意一种特殊语法，{ } 代表信号的连接，{A0, A1} 就是将 A1，A2 这两个二进制信号连接起来，组成一个两位的二进制数，后面的比较大小比较的就是这两个两位的二进制数的大小。
还有就是注意这里3个 assign 的顺序不重要，因为它们是并行执行的。

![[Pasted image 20251020235721.png]]

还有一个语法比较重要，是 always：

![[Pasted image 20251021001023.png]]

几个要注意的点：
1. always 后面的 (A or B), 也可以写作 (A, B), 是触发条件，代表 A 和 B 只要有一个值发生改变，都会触发后面的 begin - end 执行
2. 在 if - else if - else 中， 要讲究顺序了



相比高阶的RTL，由电脑自己根据目标功能完成设计，低阶的 Structural Design 拥有更高的自由性，可以进行进一步的结构优化

通常对于比较简单的结构可以借助 RTL，因为涉及自由度有限，再优化的可能性小。


### Verilog 参数化模块要点

**1. 参数化模块定义**

*   **`parameter` 关键字**: 用于在模块定义中声明常量参数。
*   **默认值**: 参数可以在定义时指定默认值。
*   **作用**: 使模块的属性（如宽度、延迟）可配置，提高代码复用性。

```verilog
module Param_Examp (y_out, a, b);
    parameter size = 8, delay = 15;  // 定义参数及默认值
    output [size-1:0] y_out;         // 使用参数定义端口宽度
    input  [size-1:0] a, b;          // 使用参数定义端口宽度
    wire   [size-1:0] #delay y_out;  // 使用参数定义延迟
endmodule
```

**2. 参数覆盖 (Parameter Override)**

*   **语法**: 在实例化模块时，使用 `#(值1, 值2, ...)` 语法。
*   **目的**: 在实例化时临时修改参数的默认值。
*   **顺序**: 参数值按其在模块定义中出现的顺序进行匹配。

```verilog
// 使用默认参数 (size=8, delay=15)
modXnor G1 (y1_out, b1, c1);

// 覆盖参数 (size=4, delay=5)
modXnor #(4, 5) G2 (y2_out, b2, c2);
```

### Verilog 模块测试要点

 **1. 待测模块 (D_ff)**

*   **功能**: D 触发器，带异步复位。
*   **输入**: `data_in`, `clk`, `rst`。
*   **输出**: `q`。
*   **行为**:
    *   在 `clk` 上升沿触发。
    *   `rst == 1` 时，`q <= 0` (异步复位)。
    *   `rst == 0` 时，`q <= data_in`。

**2. 测试平台 (Test_Bench)**

*   **目的**: 激励和观察待测模块。
*   **关键组件**:
    *   **`initial` 块**: 顺序执行，用于**初始化**和**施加激励**（如复位、数据输入）。
    *   **`always` 块**: 并发执行，用于**生成周期性信号**（如时钟）。
    *   **`#数字`**: 延迟仿真时间（单位：ns）。
*   **`$stop`**: 用于结束仿真。

**3. 仿真结果**

*   **波形图**: 显示信号随时间的变化。
*   **分析**: 通过观察波形，验证模块功能是否正确。
    *   `Q` 应在 `clk` 上升沿跟随 `D` 的值。
    *   当 `rst` 为高时，`Q` 应被清零。

# 8. Counter
一个 n-bit counter，就是一个由 n 个 Flip-Flop 组成的，有计数功能的元件；
n-bit binary counter 可以数最多 $2^{n}-1$ 个数（$2^n$ 个不同状态）

由此也可以看出它的原理，根据时钟信号，每次 rising edge，全体 Flip-Flop 就改变一次输出，我们通过逻辑门的设计，让输出的每次改变 都是 输出二进制数的加一，这就是一个简单的 counter

下图的 characteristic table 就展示了一个 3-bit Binary Counter：

![[Pasted image 20251028163716.png]]


讨论使用 D-Flip-Flop 搭建的 Counter，因为有 $D=Q^+$ , 结合上面这张 characteristic table，我们让输入口 $D_{0}, D_{1}, D_{2}$ 由 current state $Q_{0}, Q_{1}, Q_{2}$ 决定，最后可以得到这样一个描述任意 n-bit coutner 的关系规律:
![[Pasted image 20251028164147.png]]

回到 3-bit 情形，我们可以据此画出逻辑电路图：

![[Pasted image 20251028164231.png]]

<span class="green"> 输入在 rising edge 决定输出，输出在非 rising edge 决定下一轮的输入 </span>

我们管上面部分有逻辑门的区域叫 Combinational Part, 下面由3个 DFF 组成的的区域叫 Sequential Part，很显然一个是组合逻辑电路一个是时序逻辑电路。

*还有一种特殊的 Counter 叫 Asynchronous Binary Counter, 区别在于，所有 DFF 的时钟信号不再是统一控制，而是由前一个的输出Q控制。但是这种计数器在实际中因为延迟的问题不实用。*

### Load and CE (Count Enable)

为了让计数器的功能更强大，我们给他加上两个东西：Load 和 CE

回顾之前的 Counter，会发现它除了一个控制频率的时钟信号，和一个可以重置清零的 Reset 输入，没有别的外部输入，DFF的输入是由 Q的组合输出控制的

现在有了 Load 后，我们需要给它加上 n 个输入, 以 3-bit Counter 为例：Dat2，Dat1，Dat0；

![[Pasted image 20251028170845.png]]

当 Load=0，无事发生，就是普通计数器；当 Load=1，DFF们的输入口==改为由 Dat2，Dat1，Dat0 控制==，而且由于此时已经脱离上面那个 Combinational part 的控制，**计数器停止计数**，（<span class="red"> 注意不是立刻停止并改变值！这一切都是等到Load改变后的下一次 rising edge 才发生 </span>），直到 Load 回到 0；当 Load 再次等于 0 时，由于==当前输出端仍是之前 Dat2，Dat1，Dat0 ==的数值，所以计数器将==从这个数值开始计数==。

CE 的功能，简单来说就是给计数器加上了“暂停”键，==CE=1 时正常计数，CE=0 时停止==。

![[Pasted image 20251028171010.png]]

注意到，同样是操纵计数器的行为，这三个输入：Reset，Load，和 CE，它们的优先级是有区别的：
- Reset 优先级最高，只有 Reset=0 时，后面的能动起来，否则一切无意义
- 其次是 load，load 也具有让计数器停止的能力，load=1 时计数器停止计数，并被设置新的计数初始值，load=0时重新开始计数
- 最后是 CE，它的优先级最低，只有在前两个都是 0 的时候，有左右何时继续，何时暂停的能力

<span class="green"> 这种优先级安排的原因是：
- Reset 确保系统上电后能进入已知状态；
    
- Load 通常用于快速设置起始计数值；
    
- CE 仅用于临时暂停计数，不影响状态寄存器的安全性。 </span>

有的时候还会定义一个输出 CEO (Count Enable Output)
![[Pasted image 20251028203238.png]]

简单来说就是，当且仅当==计数器达到最大值，且处于正常计数状态==时，CEO才会等于 1

### Customiz Counting Sequence

![[Pasted image 20251028203735.png]]
通过在某几个输出口加上一个 AND 门，并连接到 Load，我们实现了**计数至某个特定值，计数器就自动回到某个特定值继续计数** 

在这个例子中，Q0，Q2 被 AND 连接，因此在第一次它们均为1时，也就是 101 的时候，计数器会触发 load，然后变成 Dat0~2 定义的值，也就是 000，继续开始计数；我们也可以设定 Dat0~2 为其它值
这就是自定义计数序列

### Clock Divider

原理是，通过在输出端的逻辑门组合，使得原计数器走过多个数后，逻辑门的输出端仅增加一，这样就实现了一个对时钟信号的“减缓”。
<p align="center">
  <img src="Pasted image 20251028204729.png" width="320"/>
  <img src="Pasted image 20251028204739.png" width="320"/>
</p>
上面展示了两种 Dividing，对于 Divide by 4, 因为是 2 的次方，可以直接选择一个 2-bit Counter, 然后两个输出的 AND 就可以实现

但是对于 6 不是 2 的次方，我们需要选择一个比 6 大的次方数，然后设置计数器在计数至 6-1=5 时，清零重新开始。

总之：
![[Pasted image 20251028205256.png]]

这部分剩下的内容就是各种奇奇怪怪的 Counter 了，看 Slide吧懒得记了。

- [x] 270 HW 5 ⏫ 📅 2025-11-03 ✅ 2025-11-01

# 9. Register & Shifter

## Register File 
简单来说，register file（寄存器堆）就是一组按照编号组织在一起的寄存器集合，可以通过一个地址访问其中的某个寄存器。

当我们有许多寄存器并列在一起，但是每次只需要选择一个进行读取或写入时，Register File时一个比无脑并联寄存器更高效、合理的设计
下图展示了一个寄存器堆的设计：

![[Pasted image 20251102093112.png]]

从内部看，这个寄存器堆里面有四个寄存器，分别用一个两位二进制数作为地址，可以通过左边的 decoder 输入地址进行访问，只有相应地址的哪个寄存器会被访问并写入信息（load=1 支持写入，其余寄存器load=0保持不动）。
然后右边有一列 tri-state bufffer, 用途是控制只有被选中的信号才能被传入 R_data 被读取，而控制这些 tri-state buffer 的时另一个 decoder, 也是通过输入两位二进制数地址，选择要读取的寄存器。

==从外部看它的整体功能，就是作图展示的那样，首先两个 Enable：W_en 和 R_en， 分别控制写入和读取能否发生；然后是两个地址选择：W_addr 和 R_addr, 分别控制写入哪个寄存器和读取哪个寄存器；最后是具体数据 W_data 和 R_data, 是写入数据和读取数据的通道。==

![[Pasted image 20251102094138.png]]

接下来我们研究 Register File 的 timing diagram, 如上图所示，注意到几个点，首先，只有 R_en=1 时，R_data 端能读到数据，但是==这个过程独立于时钟信号==，就是说，只要 R_en 变成1，R_data 立刻能收到数据，不用等时钟信号的 rising edge. 

这是 Register File 的 Verilog 实现：
![[Pasted image 20251102094702.png]]

注意一种语法：\[width-1:0\] memory \[number-1:0\] 左边代表列数，右边代表行数，构建了一个类似二维数组的东西。

## Shift Register
简单来说，就是将一个寄存器的输入口 Q 连接到下一个寄存器的输入口 D，这样每一轮上升信号，所有信号会向右移动一个寄存器。

![[Pasted image 20251102095014.png]]

我们可以对这个基础的 Shift Register 进行改进，首先，如果将 OUT0连接到最左边的 D 口，这就成了一个 Rotate Register，顾名思义，输出右移后不会丢失，而是回滚到前面，形成一个闭环；
<p align="center">
  <img src="Pasted image 20251103190208.png" width="320"/>
  <img src="Pasted image 20251103190227.png" width="320"/>
</p>

在最左边的 D 口前加上一个 $2\times1$MUX, 一个输入 OUT0, 另一个输入一个外部输入 Din, 这就做到了既能够选择回滚，又能选择接受新的输入

现在抛开“回滚”功能，我们考虑设计这样一个寄存器，能够 Hold 住当前的 Values，也能接受外部的输入更新储存值，最后还能不断 "Shift"，这就是一个 **Universal Shift Register**：
![[Pasted image 20251103190552.png]]

注意看它的 action table，当 Shift=Load=0 时，这个寄存器 "Hold", 保持当前值不动，当 Load=1，寄存器接受外部的输入 $D_{3},D_{2},D_{1},D_{0}$，当 Shift=1, 无论 Load 是多少，一律执行 shift 功能，向右移动。

对于这样一个 Universal Shift Register，我们有两种输入模式，也有两种输出读取模式，要么是从一端一个 bit 一个 bit 的输入或输出，要么是整体的四个寄存器一起输入或输出

这个设计可以非常有用，比如之前的汽车显示模型，我们有 8-bit 宽度的信息需要一次传给一个指定寄存器，然后由这个寄存器存储它们，在需要的时候传输给显示装置；

那么在之前的设计（上面那个），我们有4个 8-bit 寄存器（包含8个并排的 DFF），需要 8 根输入线，这8根线都是直接连着 CPU 的，显得非常浪费（总共就需要消耗11个CPU接口）

现在我们用下面这种设计，还是4个寄存器，每个寄存器里面还是8个 DFF，但是是 Universal Shift Register，我们可以只用一根输入线，每次输入进去一个 bit, 然后等8个比特都填进去后，这个寄存器也满了，我们先不动它（Shift=Load=0，Hold！)，然后等需要读取里面的值的时候，8根线连上，直接全部一起导出。

<span class="green"> 想象一把弹夹只能容纳8颗子弹突击步枪，我们先一颗一颗把子弹压进去（CPU端的输入），然后需要的时候，扣动扳机一梭子全打出去（右侧的输出读取） </span>

![[Pasted image 20251103192218.png]]

总而言之，Universal Shift Register 最好的一点是，它提供了一种牺牲时钟信号/传输速度 来换取信号线的减少 的输入/输出方法，但是事实上，我们完全可以把时钟信号的频率提高到很高，于是这点多要求的时钟信号也不算什么了
## Shifter

还有一种和 Shift Register 很像，但是本质完全不一样的模块：Shifters

![[Pasted image 20251103192629.png]]

这是通过接线的设计，实现信号的 “Shift”，我们同样可以用各种方式扩展它的能耐，像上图所示

Shifter 的最大用途，可能就是能够用来执行二进制数的乘除法运算，对于一个二进制数，将其左移一位，然后多出来的空位填0，相当于乘以2；
相反，如果右移一位，相当于除以2

# 10. Finite State Machine (FSM)
首先什么是 FSM，它是一种设计时序电路的方法，一个时序电路可以看作由以下基本要素组成：
1. 一系列状态。在任何给定时刻，系统都处于这组状态中的一个
2. 一系列的输入和输出。是整个系统接收的外部信号和做出的响应
3. 一个初始状态。是系统上电或复位后，第一个进入的状态
4. 一系列转换逻辑。定义不同状态之间的转换规则，也就是“在什么情况下，从当前状态，会进入下一个状态”
5. 一组动作（输出）。指在处于某个状态时，FSM会执行的特定操作或产生特定的输出。这通常与状态本身相关联。
![[Pasted image 20251109110815.png]]

我们可以用 state diagram 和 state table 两种方式来表示一个 FSM

这里展示了另一种 state diagram 的画法：
![[Pasted image 20251109111011.png]]

为了设计一个没有 bug 的 sequence circuit，需要遵循一些基本原则，概括下来就是：Bijective  必须有一种输出是正确的，也只能有一种输出是正确的

![[Pasted image 20251110165859.png]]

以一个颜色锁为例
<p align="center">
  <img src="Pasted image 20251110170002.png" width="320"/>
  <img src="Pasted image 20251110170015.png" width="320"/>
</p>

上图展示的就是对一个 sequence circuit 的设计修复逻辑漏洞的过程。

So far，我们见识了各种各样的 sequence circuit，以及知道了如何通过画 state diagram 来定义、描述、设计一个 FSM，那么如何把这个设计落实到逻辑电路图呢？

FSM 的一个标准架构由两部分组成：
1. State register：负责储存状态，并根据时钟信号来更新状态
2. Combinational logic：根据**输入**和**当前状态**计算**下一个状态**和**输出**
如下图所示：
![[Pasted image 20251112191813.png]]

将这个架构一步步搭建好，遵循以下步骤：
1. 把目标 FSM 描述清楚，通过 state diagram（Just go ahead！大胆画！）
2. 确定这个 FSM 的大致框架，首先是register，它用于储存该 FSM 的所有可能的状态，所以==它的输入比特应该做到能表示所有可能的状态==，也就是说输入比特数 m 应该满足 $2^m$ 大于等于状态数；
	至于 combinational logic 部分，它的输入应该是 FSM 的==输入和当前的状态编码==（状态寄存器的输出），输出则是 FSM 的==输出和下一轮的状态编码==
3. 对状态进行编码，给每个状态分配一个独一无二的二进制编码，称为 encoding, 后面寄存器就指着这个编码存储了
4. 列出 State table，现在状态们也都有了二进制编码，可以根据 state diagram 列出相应的 state table 了，这个 table 的input column 应该是FSM输入和当前状态编码，输出则是FSM输出和未来状态编码
5. 根据刚刚列的 State table，把 combinational logic 画出来

可以看一个巧妙的例子，是对 FSM 设计的应用：一个按钮的 Synchronizer；
简单来说，就是要实现不管按下多长时间，不管时钟信号有多快，每按一次，就只记一次

![[Pasted image 20251116211810.png]]

接下来，我们通过一个例子了解 FSM 如何转化成 Verilog 代码

这是我们要研究的一个 FSM 的state diagram：

![[Pasted image 20251116212117.png]]

1. 可以看到，除了定义输入输出口，我们首先对5个状态进行了编码，通过 parameter 语法；
2. 然后，简简单单，定义了一个有 reset 功能的寄存器，仅仅为了实现当前状态和未来状态的一次次赋值，和重置功能，非常简单
3. 接下来是重头戏，Combinational logic 的实现，我们知道 FSM 是输入与当前状态 去决定 输出和未来状态，那么，我们只要将当前状态和输入的各种组合情况用 case 和 if 语句分组，分别对不同情况下直接赋值就行啦，也是，非常简单
4. 最后也是最关键的，我们之前赋值的只是状态，就是说，Combinational logic 只算出了下一个状态是什么，还要将状态变成输出值，观察 diagram，发现只有在 zero_2 和 one_2 的时候输出是1，其它都是0，于是有了最后一行的赋值。（这个语法还是很眼熟的）

<p align="center">
  <img src="Pasted image 20251116212938.png" width="320"/>
  <img src="Pasted image 20251116213000.png" width="320"/>
</p>
但是这种Verilog架构是基于==输出值仅由当前状态决定==这一前提，我们在下一节会看到不满足这一前提的FSM
# FSM Optimizations

优化的目标是，在不改变功能实现的前提下，尽可能减少需要的==状态数==

## 两种 FSM，Moore 和 Mealy

**Moore FSM**: 输出仅由当前状态决定
**Mealy FSM**: 输出由当前状态和输入共同决定

可以对比一下这两种 FSM：

这是 Moore：

<p align="center">
  <img src="Pasted image 20251116214152.png" width="320"/>
  <img src="Pasted image 20251116214214.png" width="320"/>
</p>

这是 Mealy：

<p align="center">
  <img src="Pasted image 20251116214243.png" width="320"/>
  <img src="Pasted image 20251116214258.png" width="320"/>
</p>

浅浅解读一下，对于 Moore 来说，每个箭头代表在时钟信号上沿时两个状态间的切换，每落到一个新状态，输出值随之变成这个状态对应的输出值；
因为状态的切换仅在时钟信号上沿发生，所以 Moore 的输出是 synchronous 的

对于 Mealy 来说，每个状态伸出去的箭头代表在这个状态下，输入不同值会把系统引向何方，注意新输入值进来的时候时钟信号还没上升，所以状态的切换还不会发生，但是输出值不受时钟信号的控制，早已变成了相应箭头下面（分母处）的那个值（如图）
这样一来，Mealy 的输出值其实是 asynchronous 的

回到 FSM 的优化精简，我们列出 state table，然后观察，如果有两个或多个状态，它们的不同输入输出下的输出和未来状态都一模一样，那它们就可以合并为一个状态；我们将全部合并后的状态们列成一张新的、精简的 state table，然后据此画出 state diagram 和设计相应电路

下面是一个例子：

<p align="center">
  <img src="Pasted image 20251116215631.png" width="320"/>
  <img src="Pasted image 20251116215648.png" width="320"/>
</p>
