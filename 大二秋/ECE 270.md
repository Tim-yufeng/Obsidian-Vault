# 1. Introduction to Digital Design
## Digital和Analog简介

Digital signal: 数字信号，离散的、有限的可能
Analog signal：模拟信号，连续的、无限的可能
模拟信号到数字信号的转换：From analog to digital, 被称为 A2D/Digitization
意义：模拟信号容易在传播途中失真（因外界干扰因素），而数字信号因为简单，即使失真也容易恢复，因此适合用于传输
显然模拟信号包含的信息更多，因此A2D其实可以类比186中对积分的定义，用小矩阵去拟合逼近曲线，但是需要更多的 bits
![[Pasted image 20250915193049.png]]
既然数字信号更适合远程传输，那么一个我们要做的就是在传输前将模拟信号变成数字信号，传输过去后再变回来
![[Pasted image 20250915193352.png]]  
## 二进制、十六进制和八进制
二进制变成十进制很简单，只要明确每个位置的权重，再一起加起来就可以了，下图展示了考虑小数的情形：
![[Pasted image 20250915193711.png]]  
由此我们得到，$10011.01_2 = 16+2+1+0.25 = 19.25_{10}$ 

而十进制变成二进制则稍麻烦，一种方法就是直接拆解成2的次方的组合，比较适合人类。

另一种方法是：对于整数部分，不断整除2取余，将余数按照从右往左 ($\longleftarrow$) 的方向，也就是从小到大，排开就组成了二进制数的整数部分。
小数部分则不断乘以2，每次乘以2，如果大于1，则记1然后减去1，否则直接记0。将每次记录的数从左往右（$\longrightarrow$）排，就得到了小数部分。
要注意的是，不是所有十进制小数转化到二进制都是有限的（上述过程无限重复下去，永远不能被减到0的情况），比如 $0.1_{10}$ 在二进制中是无限循环小数。
By the way，许多十进制简单的小数到了二进制却变成了无限循环小数，这也正是计算机浮点数精度误差的来源。

这里仅展示小数部分的获得方式：
![[Pasted image 20250915215220.png]]  


十六进制原理上和二进制差不多，和十进制的转化的方法也大同小异。
之所以十六进制重要，是因为二进制在计算机内的储存方式是四个bit一组，也就是四位二进制数一组，而这一组bits所能表示的数刚好是16个，也就是十六进制的一个数，因此我们可以将一个巨大的二进制数分成四个一组，然后每一组直接转换成十六进制的一个数，看着就清爽多了，如下图所示：
![[Pasted image 20250915215756.png]]  
八进制的用武之地和十六进制差不多，不过现在已经被逐渐淘汰了，我们了解即可。

二进制比特表示文字：ASCII or Unicode (See slides for details)

## 负数的二进制表示

用二进制表示负数时，一种方法是，由最左边的bit代表符号，其中0为正，1为负，其余部分表示绝对值，比如 $1100_2$=$-4_{10}$ *(sign and magnitude)*

另一种方法是，将四个bits的每一个bit都flip一下，1变成0，0变成1，比如$0011_2=3_{10}$, $1100=-3_{10}$ *(1’s complement representation)*

第三种方法是，像第二种一样取反每一个bit，然后加上1，此时 $-3_{10}=1100+1=1101$ *(2’s complement representation)*

<span class="red">现代计算机采用的是第三种方法。</span>
在第三张方法下，对于正数，在最左边添加0不会改变这个数的值，对于负数，增加1不会改变值。这些增加的0或1被称为 sign extension
(<span class="green">第三种方法的优越性在于，它能够最大化利用所有bit，将 $2^n$ 种组合方式完全用于 $-2^{n-1}$ 到 $2^{n-1}-1$ 的表示，每个数唯一对应，没有“正零”和“负零”的冗余（原码和反码都有这个问题）。</span>)

在考虑了正负号后的二进制加减运算，一种方法是先遵循2's complement 将每个参与运算的数转换成符号+大小的形式，然后直接进行十进制计算；另一种就是直接进行竖式计算，只在最左边一位考虑是否舍弃最末的carry。

对于n个比特，2’s complement representation表示的范围是 $-2^{n-1}$ 到 $2^{n-1}-1$, 而如果一个n 比特的2’s complement number超过了这个范围，就称之为Overflow（溢出）。
发生溢出时，也就是**运算结果超出了当前位数2’s complement representation所能表示的范围**，最前面的carry需要保留，否则舍去。

判断是否Overflow最简单的方法是，<span class="red">次高位给最高位（or符号位）带来的进位若不等于最高位自己产生的进位，则代表Overflow。</span>
![[Pasted image 20250917201609.png]]

- [x] 270 HW 1 🛫 2025-09-17 📅 2025-09-23 ✅ 2025-09-23
作业收获：
 - 正数的二进制不用担心“最高位是 1 就是负数”，那只有在固定位宽二补数下才成立。
    
- 做运算时，先统一位宽：正数前面补 0，负数前面补 1。
    
- 转换时保持 3 位（八进制）或 4 位（十六进制）的分组，只是为了方便阅读，并不是强制要求。
一个有趣的问题是，$1000_2$ 代表负多少，因为按照 “Flip 后加1” 的操作，$1000_2-1=0111_2 \rightarrow(flip) 1000$, 回到了他自己，这是为什么？
其实是因为，n位二进制数在2’s complement representation 规则下只能表示 $-2^{n-1}$ 到 $2^{n-1}-1$ 这个范围，注意到负数的范围比正数多一个整数，所以其实是 $1000_2=-8$, 但是相应的正数8不在4位表示范围内，4位最多表示到7. 
如何知道$1000_2=-8$ ？这就需要另一个公式,对于开头是1的二进制数，也就是负数，满足：
$$值=−2^{n−1}+其余位的值$$ 其余位的值 就是除了最高位以外的部分视为一个二进制正数，它代表的值
对于$1000_2$，我们有$-2^3 +000_2=-8+0=-8$ 
# 2. Basic Logic Gates
## Transistor（晶体管）
本质是 electronic switch，是二进制数字电路的根基
特征：
- 是一个开关器件，是开是关由输入端电压决定
- 开：允许电流通过，关：阻断电流
- 其开关状态可以表示二进制逻辑：1/0
transistor分为两种：positive MOS 和 negative MOS， 如下图所示：
![[Pasted image 20250917211314.png]]  
其中1代表高电压，0代表低电压或无电压（低于阈值的电压）
nMOS在高低压导通，低电压阻断；pMOS则相反

通过这两种晶体管的组合，可以形成以下三种逻辑门：

<p align="center">
  <img src="Pasted image 20250917212014.png" width="200"/>
  <img src="Pasted image 20250917212058.png" width="200"/>
  <img src="Pasted image 20250917212107.png" width="200"/>
</p>
这三种逻辑门的运算顺序是：**NOT>AND>OR**

另一种表示逻辑输入输出的方式是Timing Diagram, 也叫 wave form, 可以描述电压信号随时间的变化特征；（其实就是不连续变化的波形图，振幅-时间的那种）
![[Pasted image 20250922163223.png]]  

更多的逻辑门包括 NAND, NOR, XOR, XNOR, 其中加上N代表……的否定，如下图所示，通过一个圈代表NOT, 而XOR表示输入的“1”个数为奇数时输出1， 否则输出0（毕竟某种意义上，二进制中1+1=0）
![[Pasted image 20250922165354.png]]
（现实中NAND和NOR比AND和OR更常用。）

逻辑电路的绘制有一些约定俗成的规则，如下图所示，有些画法是不被允许的：
![[Pasted image 20250922185356.png]]  
# 3. Boolean Algebra & Optimization
## 一些专业术语
- variable: 就是逻辑表达式中的变量，和函数变量一样
- Literal: 一个变量，以自己或者取反的形式，出现一次，就是一个literal
- Product term： AND of literals
- Sum: OR of literals
- Sum-of-products: 完全写成多项相加的式子
这是一个例子：
![[Pasted image 20250922190502.png]]  

## Boolean Algebra的基本定理
下面这些是最基本的，记住的诀窍是不要从数学的角度，从逻辑的角度（不要把 $\cdot$ 和 + 当成乘号和加号，要当成 and 和 or
![[Pasted image 20250922190554.png]]
下面这些就相对复杂了，它们由上面的基本定理推导而来，目的是化简逻辑表达式
![[Pasted image 20250922190606.png]]

**DeMorgan’s Law**
$$(x+y)'=x'y'$$
$$x'+y'=(xy)'$$

运算顺序之前提过，这里再说一次：  
==括号>NOT>AND>OR==
(你会发现和它们相应的数学符号的运算顺序是一样的)

XOR 运算因为很常用，这里也介绍一下它的运算法则：
![[Pasted image 20250922191842.png]]
一个将XOR换算成前面的基本逻辑运算的公式：
$$ A \oplus B = AB'+A'B$$ 
## Minterm and Maxterm

Minterm: n 个变量的积项（AND），并且每个变量必须出现一次（要么取正，要么取反）
比如变量是 $a, b, c$，一个可能的 minterm 是 $a b' c$。
用 $m_i$ 表示，第 $i$ 个 minterm

Maxterm: n 个变量的和项（OR），并且每个变量必须出现一次（要么取正，要么取反
比如变量是 $a, b, c$，一个可能的 maxterm 是 $(a + b' + c)$
用 $M_i$ 表示，第 $i$ 个 maxterm 

下图展示了排序的依据：
![[Pasted image 20250922193712.png]]  
实际就是上将literals们的组合方式对应到二进制，将相应的值作为$i$值了。
之所以叫 Minterm，是因为三个字母都仅出现一次，是满足“仅使得某种组合输出结果为1”的最短组合。
这种组合也是最基本的组合，被用于组合更复杂的逻辑表达式，也就是 sum-of-minterms (**standard-sum-of-products**)
举个例子：
![[Pasted image 20250924192733.png]]  
如图所示，我们可以把这种组合简写作$m_i$相加的形式，或者写成对应的脚标的求和的形式。

关于Maxterm就不多说了，因为Minterm和Maxterm可以依据 DeMorgan’s Law 相互转化，有：
$$m_i'=M_i$$ 比如，$m_0=x'y'z'$，$m_0'=(x'y'z')'=x+y+z=M_0$，
然后他们用于组合表示逻辑表达式时，index是相反/互补的：
比如：如果总共有7项，那么$\sum{m(1, 2, 4, 7)}=\prod{M(0, 3, 5, 6)}$
## Incompletely Specified Functions
还有一类逻辑表达式比较特殊，它们的某些输出我们并不care，可以是0可以是1，也就是不完全定义 (**Incompletely Specified Functions**) 
![[Pasted image 20250924194132.png]]  
我们在 truth table 的相应位置标识 "x", 代表未定义，同时在表达式里写作 $d(\cdots)$ 

# 4. Logic Optimization
## 优化简述
Optimization有两个基本指标，一是延迟减少，二是尺寸减小，其中这两个指标分别对应：
- Delay: 从输入到输出的最多层数
- Size: transistor的数量
我们可以简单的假设：
1. 每个逻辑门都产生 "1 gate delay"
2. 每个逻辑门的输入需要2个transistor
3. 不考虑NOT逻辑门，也就是 inverter
一个简单的例子：![[Pasted image 20250924202614.png]] 右边的逻辑电路和左边等价，但是transistor数量和逻辑门层数都更少，意味着它的滞后时间和尺寸都更小，因此是更优设计

要注意的是，这两个优化指标并不总是能像这样同时取得的，很多时候会面临选择低延迟，但是增大尺寸，或者反过来的局面，这个时候的设计要考虑具体需求。

从输入到输出的最长延迟路径被称作 **Critical path** 

那么，如何Optimize呢？

## Karnaugh Map (K-map) Technique

优化的方法除了 Boolean Algebra，还有Karnaugh-map
如何理解这个方法？
### 1. 从“每个格子 = 一个最小项”开始

- K 图上的每个格子，代表一个 **minterm（最小项）**。
    
- 如果不化简，函数就得写成所有“格子对应的最小项之和”。
    
### 2. 为什么可以“画圈合并”？

- 在 K 图的布局下，**相邻格子之间只差一个变量取值**。
    
- 例如：
    
    - 格子1 = $A B' C D$
        
    - 格子2 = $A B C D$
        
    - 它们相邻，只差 $B$，所以
        
        AB′CD+ABCD=ACD(B′+B)=ACDA B' C D + A B C D = A C D (B'+B) = A C DAB′CD+ABCD=ACD(B′+B)=ACD
    - 这样就**消去了一个变量**。
        

所以，“画圈”的本质 = 通过邻接性，把一组最小项合并成一个更简的项。

---

### 3. 为什么圈的大小必须是 2 的次方？

- 如果一个圈包含 **2 个格子**，说明消去 1 个变量；
    
- 如果一个圈包含 **4 个格子**，说明消去 2 个变量；
    
- 如果一个圈包含 **8 个格子**，说明消去 3 个变量；
    
- …依此类推。
    

这是因为：

- 每消去一个变量，对应情况数翻倍（2 个格子）；
    
- 所以圈内格子数 = $2^k$，其中 $k$ = 被消去的变量数。
    

---

### 4. 化简的目标

- 起点：每个“1”格子单独表示 → 全部变量都在。
    
- 过程：通过圈合并，**去掉不必要的变量**。
    
- 终点：找到覆盖所有“1”的最简表达式。

- [ ] HW 2 📅 2025-10-13 ⏫ 

在 Karnaugh-map 方法中，如果碰到某些格子是 "Don't care", 我们在相应的格子标 "X", 在画圈时，它们可以扮演1也可以扮演0. 

在 Karnaugh-map 中无法被一个更大的圈完全覆盖的区域，称为 prime implicant (PI). 
![[Pasted image 20250929162333.png]] 
如果**存在一个格子，有且仅有该 PI 覆盖到它**，那么这个PI就是一个 **essential PI**.

如果一个 PI 中所有最小项都能被其它 PI 覆盖，那么这个 PI 就是不必要的，反之，如果存在一个只能被该 PI 覆盖的最小项，那么这个 PI 就是必要的，在最终表达式中无法被其它 PI 替代

还有一种优化思路，就是将 K-map 上所有数字反转，这样就是输出结果取逆的 K-map. 写出它的化简后的逻辑表达式，然后再逆回去，可能会起到意想不到的效果

因为 K-map 法化简结果是 sum-of-product，如果先取逆后在外层逆回去，那么运用 DeMorgan's Law, 我们就可以把 sum-of-product 形式变成 product-of-sum 形式 {.green}

## 能量的优化

还有一种优化方向，就是让芯片的能量消耗最低：
芯片的能量消耗主要来自0到1的切换
![[Pasted image 20250929170817.png]] 

# 5. Combination Circuit
数字电路可以分为基础的两类，combination circuit（组合逻辑电路） 和 sequential circuit（时序逻辑电路）

Combination circuit：输出只依赖于当前输入，和历史输入无关

Sequential circuit：输出不仅取决于当前输入，还取决于电路的历史状态（有记忆功能）


